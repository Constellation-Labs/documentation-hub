---
title: Data API
sidebar_label: Data API
hide_table_of_contents: false
---

<intro-end />

The Data API is a module available to Currency Framework developers to ingest and validate custom data types through their metagraphs. It's a set of tools for managing data interactions within the metagraph that is flexible enough to support a wide range of application use cases such as IoT, NFTs, or custom application-specific blockchains. 

:::info Example Code
Want to jump directly to a code example? A number of examples can be found on Github under the [Metagraph Examples](https://github.com/Constellation-Labs/metagraph-examples/tree/main/examples) repo.
:::

## Data Application Architecture
Data applications or metagraphs implementing the Data API are built on top of the Currency Framework. In a standard Currency Framework metagraph, the metagraph consists of 3 mL0 (metagraph L0) nodes and 3 cL1 (currency L1) nodes. Data applications build on top of this structure and introduce a 2nd L1 layer that runs in parallel with the currency L1 layer. A data application's minimal structure consists of 3 mL0 (metagraph l0) nodes, 3 dL1 (data L1) nodes, and optionally 3 cL0 (currency l0) nodes. Blocks produced by both the cL1 and dL1 nodes undergo consensus on the L0 layer and their data is grouped together within metagraph snapshots. 

### The DataApplication Instance
Data Applications provide an instance of `BaseDataApplicationL0Service` and `BaseDataApplicationL1Service` to the L0 and Data L1 CurrencyApp definitions, found in Main.scala for L0 and L1 respectively. The definition of these services contain a set of overridable methods that allow the developer to provide custom data validation logic to the existing application flow. 

A Data Application, at it's core, is about state management. We define our initial state shape, accept data updates to the application, accept or reject those updates based on validation criteria, and then return a new state on each snapshot. 


### Data Update Lifecycle
__Data L1 layer lifecycle__
1. Update received by POST endpoint on L1 (POST `/data`)
2. Update is decoded as `Signed[DataUpdate]`
3. `deserializeUpdate` called
4. Signature validated
5. `validateUpdate` called
6. Data enqueued for L1 consensus


__L0 layer lifecycle__
1. `validateData` called
2. `combine` called
3. `serializeState` called

### The Data Endpoint
Data is submitted to an application via a single REST endpoint on Data L1 nodes, located at `/data`. By default, this endpoint accepts data as a signed JSON request in the following format:

```json
{
  "value": {
    // This type is defined by your application code
  },
  "proofs": [{
    "id": "<public key>",
    "signature": "<signature of data in value key above>"
  }]
}
```

The endpoint is designed to support multiple data types through a single access point, and these types are parsed within your application code. To accommodate different types of data, you should implement a lifecycle function named `signedDataEntityDecoder`. This function takes in your data and converts it to the `Signed[DataUpdate]` class, as defined in your application. For a practical example on how requests are parsed into the `Signed[DataUpdate]` class, refer to the [DOR Metagraph example](https://github.com/Constellation-Labs/dor-metagraph).

### OnChainState vs. CalculatedState
The DataAPI encompasses two distinct types of states: `OnChainState` and `CalculatedState`, each serving unique purposes:

* `OnChainState`: As the name implies, this state contains all the information intended to be permanently stored on the blockchain. The metagraph snapshots have a storage limit of 500 KB, which necessitates careful management of the size and content of the information stored in this state, as it will remain on the blockchain.

* `CalculatedState`: This state exists off-chain and is constructed based on incoming data. It is not stored on the blockchain, allowing for the management of larger volumes of information. The CalculatedState is generated by iterating over metagraph snapshots and invoking the combine lifecycle function. Typically, this state is stored in memory, but it can be customized according to specific needs. Several lifecycle functions are crucial for managing CalculatedState: `getCalculatedState`, `setCalculatedState`, and `hashCalculatedState`.
 
The [Metagraph Examples](https://github.com/Constellation-Labs/metagraph-examples/tree/main/examples) provide insights into how both states are utilized, with `CalculatedState` often employed to maintain data structures like `Map`. These structures facilitate the integration or updating of information based on previous data entries.
 
### Lifecycle Methods
#### genesis
A Data Application enables developers to define state schemas for their metagraph. Initial states are set in the `genesis` method of the `DataApplicationL0Service`, which can be overridden:

The definition for `OnChainState` must extend the `DataOnChainState` class.
The definition for `CalculatedState` must extend the `DataCalculatedState` class.
For example, you can define states using map types as shown in the Scala code below:

```scala
class OnChainState(updates: List[Update]) extends DataOnChainState
class CalculatedState(info: Map[String, String]) extends DataCalculatedState

override def genesis: DataState[OnChainState, CalculatedState] = DataState(OnChainState(List.empty), CalculatedState(Map.empty))
```

#### signedDataEntityDecoder
This method parses the custom request at the `/data` endpoint into the `Signed[Update]` type. By default, you can use the `circeEntityDecoder` to parse the JSON:
```json
{
  "value": {
    // This type is defined by your application code
  },
  "proofs": [{
    "id": "<public key>",
    "signature": "<signature of data in value key above>"
  }]
}
```
Here one example of how to use it: 
```scala
  def signedDataEntityDecoder[F[_] : Async: Env]: EntityDecoder[F, Signed[Update]] = {
    EntityDecoder.decodeBy(MediaType.text.plain) { msg =>
      val update = Update(msg)
      val hexId = Hex("myPubKey")
      val hexSignature = Hex("mySignature")

      val signatureProof = SignatureProof(Id(hexId), Signature(hexSignature))
      val proofs = NonEmptySet.fromSetUnsafe(SortedSet(signatureProof))

      Signed(update, proofs)
    }
  }
```

#### validateUpdate
This method validates the update on the L1 layer and can return synchronous errors through the /data API endpoint. Context information (oldState, etc.) is not available to this method so validations need to be based on the contents of the update only. Validations requiring context should be run in `validateData` instead.

For example, validate a field is within a positive range:
```scala
def validateUpdate(update: Update): IO[DataApplicationValidationErrorOr[Unit]] = IO {
  if (update.usage <= 0) {
    DataApplicationValidationError.invalidNec
  } else {
    ().validNec
  }
}
```

#### validateData
This method runs on the L0 layer and validates an update (data) that has passed L1 validation and consensus. `validateData` has access to the old or current application state, and a list of updates. Validations that require access to state information should be run here. 

For example, validate that a user has a balance before allowing an action:
```scala
def validateData(oldState: DataState[OnChainState, CalculatedState], updates: NonEmptyList[Signed[Update]]): IO[DataApplicationValidationErrorOr[Unit]] = IO {
  updates
    .map(_.value)
    .map {
      val currentBalance = acc.balances.getOrElse(update.address, 0)

      if (currentBalance > 0) {
        ().validNec 
      } else {
        DataApplicationValidationError.invalidNec
      }
    }
    .reduce
}
```

#### combine
The `combine` method accepts the current state and a list of validated updates and should return the new state. This is where state is ultimately updated to generate the new snapshot state. 

For example, subtract one from a balance map:
```scala
def combine(oldState: DataState[OnChainState, CalculatedState], updates: NonEmptyList[Signed[Update]]): IO[State] = IO {
  updates.foldLeft(oldState) { (acc, update) =>
    val currentBalance = acc.balances.getOrElse(update.address, 0)

    acc.focus(_.balances).modify(_.updated(update.address, currentBalance - 1))
  }
}
```

#### serializeState and deserializeState
These methods are required to convert the onChain state to and from byte arrays, used in the snapshot, and the State class defined in the genesis method.  

For example, serialize to/from a State object:
```scala
  def serializeState(state: OnChainState): IO[Array[Byte]] = IO {
    state.asJson.deepDropNullValues.noSpaces.getBytes(StandardCharsets.UTF_8)
  }

  def deserializeState(bytes: Array[Byte]): IO[Either[Throwable, OnChainState]] = IO {
    parser.parse(new String(bytes, StandardCharsets.UTF_8)).flatMap { json =>
      json.as[State]
    }
  }
```

#### serializeCalculatedState and deserializeCalculatedState
These methods are required to convert the calculated state to and from byte arrays, used in the snapshot, and the State class defined in the genesis method.  

For example, serialize to/from a State object:
```scala
  def serializeCalculatedState(state: CalculatedState): IO[Array[Byte]] = IO {
    state.asJson.deepDropNullValues.noSpaces.getBytes(StandardCharsets.UTF_8)
  }

  def deserializeCalculatedState(bytes: Array[Byte]): IO[Either[Throwable, CalculatedState]] = IO {
    parser.parse(new String(bytes, StandardCharsets.UTF_8)).flatMap { json =>
      json.as[State]
    }
  }
```

#### serializeUpdate and deserializeUpdate
These methods are required to convert updates sent to the `/data` endpoint to and from byte arrays. Signatures are checked against the byte value of the `value` key of the update so these methods give the option to introduce custom logic for how data is signed by the client. 

For example, serialize to/from a JSON update:
```scala
  def serializeUpdate(update: Update): IO[Array[Byte]] = IO {
    update.asJson.deepDropNullValues.noSpaces.getBytes(StandardCharsets.UTF_8)
  }

  def deserializeUpdate(bytes: Array[Byte]): IO[Either[Throwable, Update]] = IO {
    parser.parse(new String(bytes, StandardCharsets.UTF_8)).flatMap { json =>
      json.as[Update]
    }
  }
```

#### setCalculatedState
This function updates the `calculatedState`. Below is an example of how to implement an in-memory update of `calculatedState`.
```scala
  override def setCalculatedState(
    ordinal: SnapshotOrdinal,
    state  : CalculatedState
  )(implicit context: L0NodeContext[IO]): IO[Boolean] = {
      val currentCalculatedState = currentState.state
      val updated = state.devices.foldLeft(currentCalculatedState.devices) {
        case (acc, (address, value)) =>
          acc.updated(address, value)
      }

      CalculatedState(snapshotOrdinal, CalculatedState(updated))
    }.as(true)
        
```

#### getCalculatedState
This function retrieves the `calculatedState`. Below is an example of how to implement the retrieval of `calculatedState`.
```scala
  override def getCalculatedState(implicit context: L0NodeContext[IO]): IO[(SnapshotOrdinal, CheckInDataCalculatedState)] = 
  currentState.state.map(calculatedState => (calculatedState.ordinal, calculatedState.state))
        
```

#### hashCalculatedState
This function hashes the `calculatedState`, which is used for `proofs`. Below is an example of how to implement the hashing of `calculatedState`.
```scala
  override def hashCalculatedState(
    state: CalculatedState
  )(implicit context: L0NodeContext[IO]): IO[Hash] = {
    val jsonState = state.asJson.deepDropNullValues.noSpaces
    Hash.fromBytes(jsonState.getBytes(StandardCharsets.UTF_8))
  }
        
```

### Custom HTTP Endpoints
Custom GET endpoints can be defined as part of the `routes` overridable method of `BaseDataApplicationL1Service`. These endpoints can be used to provide custom views into snapshot state, or for any custom handling that the developer wishes to include as part of the application. 

For example, a simple endpoint that returns all "addresses" from state might look like this
```scala
  override def routes(implicit context: L1NodeContext[IO]): HttpRoutes[IO] = HttpRoutes.of {
      case GET -> Root / "addresses" =>
        OptionT(context.getLastCurrencySnapshot)
          .flatMap(_.data.toOptionT)
          .flatMapF(deserializeState(_).map(_.toOption))
          .value
          .flatMap {
            case Some(value) =>
              Ok(value.addresses)
            case None =>
              NotFound()
          }
  }
```

A full example can be seen in the [DataAPI example IoT project](https://github.com/Constellation-Labs/metagraph-examples/blob/8f4a77cc51d5ea5d1ab458767766e49fbab52f7e/examples/water-and-energy-usage/modules/l0/src/main/scala/com/my/water_and_energy_usage/l0/Main.scala#L128). 